package org.apache.jasper.compiler;

import java.io.*;
import javax.servlet.jsp.tagext.TagLibraryInfo;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;
import org.apache.jasper.JasperException;
import org.apache.jasper.JspCompilationContext;

/**
 * Class implementing a parser for a JSP document, that is, a JSP page in XML
 * syntax.
 *
 * @author Jan Luehe
 */

public class JspDocumentParser extends DefaultHandler implements TagConstants {

    private static final String XMLNS = "xmlns:";
    private static final String XMLNS_JSP = "xmlns:jsp";
    private static final String JSP_VERSION = "version";
    private static final String URN_JSPTLD = "urn:jsptld:";

    ParserController parserController;

    // XXX
    private JspCompilationContext ctxt;
    
    // XML document source
    private InputSource inputSource;

    // XXX
    private String path;

    // Node representing the XML element currently being parsed
    private Node current;

    // document locator
    private Locator locator;

    // XXX
    TagLibraries libraries;

    /**
     * Constructor
     */
    public JspDocumentParser(JspCompilationContext ctxt,
			     ParserController pc,
			     String path,
			     InputStreamReader reader) {
	this.parserController = pc;
	this.ctxt = ctxt;
	this.path = path;
	this.inputSource = new InputSource(reader);
	this.libraries = new TagLibraries(ctxt.getClassLoader());
    }

    /**
     * Parses the JSP document.
     *
     * @throws JasperException XXX
     */
    public Node.Nodes parse(Node parent) throws JasperException {
	Node.Nodes pageNodes = null;
	current = parent;

	try {
	    // Use the default (non-validating) parser
	    SAXParserFactory factory = SAXParserFactory.newInstance();

	    // Parse the input
	    SAXParser saxParser = factory.newSAXParser();
	    saxParser.parse(inputSource, this);

	    System.out.println(current);
	    if (parent == null) {
		// Add the jsp:root element to the result
		pageNodes = new Node.Nodes();
		pageNodes.add(current);
	    }
	    else {
		pageNodes = parent.getBody();
	    }
	} catch (Exception e) {
	    throw new JasperException(e);
	}

	return pageNodes;
    }

    /**
     * Receives notification of the start of an element.
     */
    public void startElement(String uri,
			     String localName,
			     String qName,
			     Attributes attrs) throws SAXException {
	Mark start = new Mark(path, locator.getLineNumber(),
			      locator.getColumnNumber());

	Node node = null;	
	if (qName.equals(XML_ROOT)) {
	    node = new Node.JspRoot(attrs, start);
	    try {
		addCustomTagLibraries(attrs);
	    } catch (JasperException je) {
		throw new SAXException(je);
	    }
	} else if (qName.equals(XML_PAGE_DIRECTIVE)) {
	    node = new Node.PageDirective(attrs, start, current);
	} else if (qName.equals(XML_INCLUDE_DIRECTIVE)) {
	    node = new Node.IncludeDirective(attrs, start, current);
	    try {
		parserController.parse(attrs.getValue("file"), node);
	    } catch (Exception e) {
		throw new SAXException(e);
	    }
	} else if (qName.equals(XML_DECLARATION)) {
	    node = new Node.Declaration(start, current);
	} else if (qName.equals(XML_SCRIPTLET)) {
	    node = new Node.Scriptlet(start, current);
	} else if (qName.equals(XML_EXPRESSION)) {
	    node = new Node.Expression(start, current);
	} else if (qName.equals(XML_USE_BEAN)) {
	    node = new Node.UseBean(attrs, start, current);
	} else if (qName.equals(XML_SET_PROPERTY)) {
	    node = new Node.SetProperty(attrs, start, current);
	} else if (qName.equals(XML_GET_PROPERTY)) {
	    node = new Node.GetProperty(attrs, start, current);
	} else if (qName.equals(XML_INCLUDE)) {
	    node = new Node.IncludeAction(attrs, start, current);
	} else if (qName.equals(XML_FORWARD)) {
	    node = new Node.ForwardAction(attrs, start, current);
	} else if (qName.equals(XML_PARAM)) {
	    node = new Node.ParamAction(attrs, start, current);
	} else if (qName.equals(XML_PARAMS)) {
	    node = new Node.ParamsAction(start, current);
	} else if (qName.equals(XML_PLUGIN)) {
	    node = new Node.PlugIn(attrs, start, current);
	} else if (qName.equals(XML_TEXT)) {
	    node = new Node.TemplateText(null, start, current);
	} else {
	    node = getCustomTag(qName, attrs, start, current);
	    if (node == null) {
		node = new Node.UninterpretedTag(attrs, start, qName, current);
	    }
	}

	current = node;
    }

    /**
     * Receives notification of character data inside an element.
     *
     * @param buf The characters
     * @param offset The start position in the character array
     * @param len The number of characters to use from the character array
     *
     * @throws SAXException
     */
    public void characters(char[] buf,
			   int offset,
			   int len) throws SAXException {
	char[] bufCopy = new char[len];
	System.arraycopy(buf, offset, bufCopy, 0, len);
	new Node.TemplateText(bufCopy, null, current);
    }

    /**
     * Receives notification of the end of an element.
     */
    public void endElement(String uri,
			   String localName,
			   String qName) throws SAXException {
	if (current instanceof Node.ScriptingElement) {
	    checkScriptingBody(current.getBody());
	}
	current = current.getParent();
    }

    /**
     * Receives the document locator.
     *
     * @param locator the document locator
     */
    public void setDocumentLocator(Locator locator) {
	this.locator = locator;
    }

    
    //*********************************************************************
    // Private utility methods

    /*
     * Checks if the XML element with the given tag name is a custom action,
     * and returns the corresponding Node object.
     */
    private Node getCustomTag(String qName,
			      Attributes attrs,
			      Mark start,
			      Node parent) throws SAXException {
	int colon = qName.indexOf(':');
	if (colon == -1) {
	    return null;
	}

	String prefix = qName.substring(0, colon);
	String shortTagName = qName.substring(colon + 1);
	if (shortTagName.length() == 0) {
	    return null;
	}

	// Check if this is a user-defined (custom) tag
	try {
	    if (!libraries.isUserDefinedTag(prefix, shortTagName)) {
		return null;
	    }
	} catch (Exception e) {
	    throw new SAXException(e);
	}

	return new Node.CustomTag(attrs, start, prefix, shortTagName, parent);
    }

    /*
     * Parses the xmlns:prefix attributes from the jsp:root element and adds 
     * the corresponding TagLibraryInfo objects to the set of custom tag
     * libraries.
     */
    private void addCustomTagLibraries(Attributes attrs)
	        throws JasperException {
        int len = attrs.getLength();
        for (int i=0; i<len; i++) {
	    String qName = attrs.getQName(i);
	    if (!qName.startsWith(XMLNS_JSP)
		&& !qName.startsWith(JSP_VERSION)) {

		// get the prefix
		String prefix = null;
		try {
		    prefix = qName.substring(XMLNS.length());
		} catch (StringIndexOutOfBoundsException e) {
		    continue;
		}

		// get the uri
		String uri = attrs.getValue(i);
		if (uri.startsWith(URN_JSPTLD)) {
		    // uri value is of the form "urn:jsptld:path"
		    uri = uri.substring(URN_JSPTLD.length());
		}

		// get the location
		String[] location = ctxt.getTldLocation(uri);

		TagLibraryInfo tl = new TagLibraryInfoImpl(ctxt,
							   prefix,
							   uri,
							   location);
		libraries.addTagLibrary(prefix, tl);
	    }
        }
    }

    /*
     * Ensures that the given body of a scripting element (that is, the body
     * of a declaration, scriptlet, or expression) does not contain more than
     * a single node, which must be an instance of TemplateText.
     */
    private void checkScriptingBody(Node.Nodes body) throws SAXException {
	if (body != null) {
	    if (body.size() > 1) {
		throw new SAXException("More than one body node");
	    }
	    Node n = body.getNode(0);
	    if (!(n instanceof Node.TemplateText)) {
		throw new SAXException("Body node not an instance of "
				       + "TemplateText");
	    }
	}
    }
}
